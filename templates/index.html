<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeckSurfer - Smart Anki Organization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .step {
            margin-bottom: 40px;
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .step-number {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }

        .step-title {
            font-size: 1.5rem;
            color: #333;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        input[type="file"], input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input[type="file"]:focus, input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .file-drop-zone {
            border: 3px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-info {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            width: 0%;
        }

        .status-indicator {
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 600;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .results-section {
            display: none;
            margin-top: 30px;
        }

        .match-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            transition: all 0.3s ease;
        }

        .match-card.selected {
            border-color: #28a745;
            background: #d4edda;
        }

        .match-card.rejected {
            border-color: #dc3545;
            background: #f8d7da;
            opacity: 0.7;
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .lo-text {
            font-weight: 600;
            color: #333;
            flex: 1;
            margin-right: 15px;
        }

        .score-badge {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .card-preview {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .card-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .match-candidates {
            margin-top: 15px;
        }

        .candidate-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .candidate-card:hover {
            border-color: #667eea;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.1);
        }

        .candidate-card.selected {
            border-color: #28a745;
            background: #f8fff9;
        }

        .candidate-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 10px;
        }

        .score-container {
            display: flex;
            gap: 10px;
        }

        .score-item {
            font-size: 0.85rem;
            padding: 2px 8px;
            border-radius: 12px;
            background: #e9ecef;
        }

        .hidden {
            display: none;
        }

        .los-preview {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .los-preview h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .los-preview ol {
            padding-left: 20px;
        }

        .los-preview li {
            margin: 5px 0;
            color: #666;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .main-card {
                padding: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .summary-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÑ‚Äç‚ôÇÔ∏è DeckSurfer</h1>
            <p>Smart Anki deck organization for medical students</p>
        </div>

        <div class="main-card">
            <!-- Connection Status -->
            <div id="connectionStatus" class="connection-status disconnected">
                <span>üîç</span>
                <span id="connectionText">Checking AnkiConnect...</span>
            </div>

            <!-- Step 1: Upload Learning Objectives -->
            <div class="step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h2 class="step-title">Upload Learning Objectives</h2>
                </div>

                <div class="form-group">
                    <label>Choose your input method:</label>
                    <select id="inputMethod" onchange="toggleInputMethod()">
                        <option value="csv">CSV File with Learning Objectives</option>
                        <option value="pdf">PDF Lecture (Auto-extract objectives)</option>
                        <option value="text">Manual Text Input</option>
                    </select>
                </div>

                <!-- CSV Upload -->
                <div id="csvInput" class="form-group">
                    <label>Upload CSV File:</label>
                    <div class="file-drop-zone" onclick="document.getElementById('csvFile').click()" ondrop="handleDrop(event, 'csv')" ondragover="handleDragOver(event)">
                        <div>üìÑ Drop your CSV file here or click to browse</div>
                        <div class="file-info">Should contain a column named 'Objective', 'LO', or 'Objectives'</div>
                    </div>
                    <input type="file" id="csvFile" accept=".csv" style="display: none;" onchange="handleFileSelect(event, 'csv')">
                    <div id="csvFileInfo" class="file-info"></div>
                </div>

                <!-- PDF Upload -->
                <div id="pdfInput" class="form-group hidden">
                    <label>Upload PDF Lecture:</label>
                    <div class="file-drop-zone" onclick="document.getElementById('pdfFile').click()" ondrop="handleDrop(event, 'pdf')" ondragover="handleDragOver(event)">
                        <div>üìö Drop your lecture PDF here or click to browse</div>
                        <div class="file-info">We'll automatically extract learning objectives from the content</div>
                    </div>
                    <input type="file" id="pdfFile" accept=".pdf" style="display: none;" onchange="handleFileSelect(event, 'pdf')">
                    <div id="pdfFileInfo" class="file-info"></div>
                </div>

                <!-- Manual Text Input -->
                <div id="textInput" class="form-group hidden">
                    <label>Enter Learning Objectives (one per line):</label>
                    <textarea id="manualObjectives" rows="8" placeholder="Enter each learning objective on a new line...&#10;&#10;Example:&#10;Describe the pathophysiology of diabetes mellitus&#10;Explain the mechanism of action of insulin&#10;Identify clinical signs of diabetic ketoacidosis"></textarea>
                </div>

                <!-- Preview Extracted LOs -->
                <div id="losPreview" class="los-preview hidden">
                    <h4>üìã Extracted Learning Objectives:</h4>
                    <ol id="losPreviewList"></ol>
                    <div class="file-info">
                        <span id="losCount">0</span> objectives found.
                        <button class="btn btn-secondary" onclick="editObjectives()" style="margin-left: 10px; padding: 5px 10px; font-size: 14px;">‚úèÔ∏è Edit</button>
                    </div>
                </div>

                <button class="btn btn-primary" onclick="extractObjectives()" id="extractBtn" disabled>
                    üìñ Extract Learning Objectives
                </button>
            </div>

            <!-- Step 2: Configure Settings -->
            <div class="step">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h2 class="step-title">Configure Matching Settings</h2>
                </div>

                <div class="settings-grid">
                    <div class="form-group">
                        <label>Target Deck Name:</label>
                        <input type="text" id="targetDeck" placeholder="e.g., USUHS::MS1::Endo::Lecture 07" value="">
                        <div class="file-info">Where matched cards will be moved</div>
                    </div>

                    <div class="form-group">
                        <label>Source Decks to Search:</label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="ankingDeck" checked>
                            <label for="ankingDeck">AnKing Step Deck</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="usuhs" checked>
                            <label for="usuhs">USUHS v2.2</label>
                        </div>
                        <input type="text" id="customDecks" placeholder="Add custom deck names (comma-separated)">
                    </div>

                    <div class="form-group">
                        <label>Optional Tag to Add:</label>
                        <input type="text" id="customTag" placeholder="e.g., LO::Endo07">
                        <div class="file-info">Tags help organize your matched cards</div>
                    </div>

                    <div class="form-group">
                        <label>Matching Mode:</label>
                        <select id="matchingMode">
                            <option value="smart">Smart (AI + Fuzzy matching)</option>
                            <option value="fuzzy">Fuzzy text matching only</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Auto-approval threshold (0.0-1.0):</label>
                        <input type="number" id="autoThreshold" min="0" max="1" step="0.1" placeholder="0.8">
                        <div class="file-info">Automatically select matches above this confidence score</div>
                    </div>

                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="multiSelect">
                            <label for="multiSelect">Allow multiple cards per objective</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="dryRun" checked>
                            <label for="dryRun">Preview mode (don't modify Anki yet)</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Process -->
            <div class="step">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h2 class="step-title">Process & Review Matches</h2>
                </div>

                <button class="btn btn-primary" onclick="startMatching()" id="processBtn" disabled>
                    üöÄ Start Matching Process
                </button>

                <div id="statusIndicator" class="status-indicator hidden">
                    <div id="statusText">Processing...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="resultsSection" class="results-section">
                    <h3>üìä Matching Results</h3>

                    <!-- Summary Stats -->
                    <div id="summaryStats" class="summary-stats"></div>

                    <!-- Results Container -->
                    <div id="resultsContainer"></div>

                    <!-- Action Buttons -->
                    <div style="margin-top: 30px; text-align: center; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="applyChanges()" id="applyBtn">
                            ‚úÖ Apply Selected Changes
                        </button>
                        <button class="btn btn-secondary" onclick="selectAll()" id="selectAllBtn">
                            üìã Select All Matches
                        </button>
                        <button class="btn btn-secondary" onclick="clearSelections()" id="clearBtn">
                            üóëÔ∏è Clear Selections
                        </button>
                        <button class="btn btn-secondary" onclick="exportResults()" id="exportBtn">
                            üì• Export Results
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="main-card">
            <h3>üìã Prerequisites</h3>
            <ul style="margin: 20px 0; padding-left: 30px;">
                <li>Have Anki running on your computer</li>
                <li>Install the <strong>AnkiConnect</strong> add-on (Code: 2055492159)</li>
                <li>Restart Anki after installing the add-on</li>
                <li>Make sure AnkiConnect is enabled in Tools ‚Üí Add-ons</li>
            </ul>

            <h3>üéØ How It Works</h3>
            <p style="margin: 20px 0; line-height: 1.6;">
                DeckSurfer uses AI and fuzzy text matching to find Anki cards that match your learning objectives.
                It searches through your existing decks (like AnKing), finds the best matches, and can automatically
                organize them into topic-specific decks. Perfect for medical students who want to align their
                Anki reviews with lecture content!
            </p>
        </div>
    </div>

    <script>
        // Global state
        let extractedLOs = [];
        let matchingResults = null;
        let selectedMatches = [];
        let sessionId = null;

        // API base URL
        const API_BASE = window.location.origin + '/api';

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            toggleInputMethod();
            checkConnection();
        });

        // ==================== CONNECTION MANAGEMENT ====================
        async function checkConnection() {
            try {
                const response = await fetch(`${API_BASE}/anki/connection`);
                const data = await response.json();

                const statusEl = document.getElementById('connectionStatus');
                const textEl = document.getElementById('connectionText');

                if (data.connected) {
                    statusEl.className = 'connection-status connected';
                    textEl.textContent = `‚úÖ Connected to Anki (v${data.version})`;
                } else {
                    statusEl.className = 'connection-status disconnected';
                    textEl.textContent = `‚ùå Cannot connect to AnkiConnect: ${data.error}`;
                }
            } catch (error) {
                const statusEl = document.getElementById('connectionStatus');
                const textEl = document.getElementById('connectionText');
                statusEl.className = 'connection-status disconnected';
                textEl.textContent = '‚ùå Cannot connect to backend server';
            }
        }

        // ==================== FILE HANDLING ====================
        function toggleInputMethod() {
            const method = document.getElementById('inputMethod').value;
            document.getElementById('csvInput').classList.toggle('hidden', method !== 'csv');
            document.getElementById('pdfInput').classList.toggle('hidden', method !== 'pdf');
            document.getElementById('textInput').classList.toggle('hidden', method !== 'text');

            // Enable/disable extract button
            updateExtractButton();
        }

        function updateExtractButton() {
            const method = document.getElementById('inputMethod').value;
            const extractBtn = document.getElementById('extractBtn');

            let canExtract = false;

            if (method === 'csv' && document.getElementById('csvFile').files.length > 0) {
                canExtract = true;
            } else if (method === 'pdf' && document.getElementById('pdfFile').files.length > 0) {
                canExtract = true;
            } else if (method === 'text' && document.getElementById('manualObjectives').value.trim()) {
                canExtract = true;
            }

            extractBtn.disabled = !canExtract;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDrop(event, type) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const fileInput = type === 'csv' ? 'csvFile' : 'pdfFile';
                document.getElementById(fileInput).files = files;
                handleFileSelect({ target: { files: files } }, type);
            }
        }

        async function handleFileSelect(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const infoElement = document.getElementById(type + 'FileInfo');
            infoElement.innerHTML = `‚úÖ Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;

            // Upload file to server
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch(`${API_BASE}/upload`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    sessionId = data.session_id;
                    infoElement.innerHTML += ` - Uploaded successfully`;
                    updateExtractButton();
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                infoElement.innerHTML = `‚ùå Upload failed: ${error.message}`;
            }
        }

        // ==================== LEARNING OBJECTIVES EXTRACTION ====================
        async function extractObjectives() {
            const method = document.getElementById('inputMethod').value;
            const extractBtn = document.getElementById('extractBtn');

            extractBtn.disabled = true;
            extractBtn.textContent = 'üîÑ Extracting...';

            try {
                let requestData = {};

                if (method === 'text') {
                    requestData.text = document.getElementById('manualObjectives').value;
                } else {
                    requestData.session_id = sessionId;
                }

                const response = await fetch(`${API_BASE}/process/extract-los`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                const data = await response.json();

                if (response.ok) {
                    extractedLOs = data.learning_objectives;
                    displayLOsPreview();
                    document.getElementById('processBtn').disabled = false;
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert(`Failed to extract objectives: ${error.message}`);
            } finally {
                extractBtn.disabled = false;
                extractBtn.textContent = 'üìñ Extract Learning Objectives';
            }
        }

        function displayLOsPreview() {
            const previewEl = document.getElementById('losPreview');
            const listEl = document.getElementById('losPreviewList');
            const countEl = document.getElementById('losCount');

            listEl.innerHTML = '';
            extractedLOs.forEach(lo => {
                const li = document.createElement('li');
                li.textContent = lo;
                listEl.appendChild(li);
            });

            countEl.textContent = extractedLOs.length;
            previewEl.classList.remove('hidden');
        }

        function editObjectives() {
            const newText = extractedLOs.join('\n');
            const result = prompt('Edit learning objectives (one per line):', newText);

            if (result !== null) {
                extractedLOs = result.split('\n').filter(lo => lo.trim()).map(lo => lo.trim());
                displayLOsPreview();
            }
        }

        // ==================== MATCHING PROCESS ====================
        async function startMatching() {
            if (extractedLOs.length === 0) {
                alert('Please extract learning objectives first.');
                return;
            }

            const config = gatherConfiguration();
            if (!config) return;

            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const progressFill = document.getElementById('progressFill');

            statusIndicator.classList.remove('hidden');
            statusIndicator.className = 'status-indicator status-warning';

            try {
                // Start processing
                statusText.textContent = 'üîç Connecting to AnkiConnect...';
                progressFill.style.width = '10%';

                const response = await fetch(`${API_BASE}/process/match-cards`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                statusText.textContent = 'üìö Loading candidate cards...';
                progressFill.style.width = '30%';

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error);
                }

                statusText.textContent = 'ü§ñ Running matching algorithm...';
                progressFill.style.width = '70%';

                // Simulate processing time for UX
                await new Promise(resolve => setTimeout(resolve, 1000));

                statusText.textContent = 'üìä Generating results...';
                progressFill.style.width = '90%';

                matchingResults = data;
                displayResults();

                statusIndicator.className = 'status-indicator status-success';
                statusText.textContent = '‚úÖ Matching complete! Review results below.';
                progressFill.style.width = '100%';

                document.getElementById('resultsSection').style.display = 'block';

            } catch (error) {
                statusIndicator.className = 'status-indicator status-error';
                statusText.textContent = `‚ùå Error: ${error.message}`;
                progressFill.style.width = '0%';
            }
        }

        function gatherConfiguration() {
            const targetDeck = document.getElementById('targetDeck').value.trim();
            if (!targetDeck) {
                alert('Please enter a target deck name.');
                return null;
            }

            const sourceDecks = [];
            if (document.getElementById('ankingDeck').checked) {
                sourceDecks.push('AnKing Step Deck');
            }
            if (document.getElementById('usuhs').checked) {
                sourceDecks.push('USUHS v2.2');
            }

            const customDecks = document.getElementById('customDecks').value
                .split(',')
                .map(d => d.trim())
                .filter(d => d);
            sourceDecks.push(...customDecks);

            if (sourceDecks.length === 0) {
                alert('Please select at least one source deck.');
                return null;
            }

            return {
                learning_objectives: extractedLOs,
                target_deck: targetDeck,
                source_decks: sourceDecks,
                custom_tag: document.getElementById('customTag').value.trim() || null,
                matching_mode: document.getElementById('matchingMode').value,
                auto_threshold: parseFloat(document.getElementById('autoThreshold').value) || null,
                multi_select: document.getElementById('multiSelect').checked,
                max_per_lo: 3,
                diversity_mode: 'none',
                alpha: 0.6
            };
        }

        // ==================== RESULTS DISPLAY ====================
        function displayResults() {
            displaySummaryStats();
            displayMatchCards();

            // Initialize selections from auto-selected matches
            selectedMatches = [];
            matchingResults.results.forEach(result => {
                if (result.auto_selected && result.auto_selected.length > 0) {
                    result.auto_selected.forEach(match => {
                        selectedMatches.push({
                            learning_objective: result.learning_objective,
                            note_id: match.note_id,
                            ...match
                        });
                    });
                }
            });

            updateSelectionUI();
        }

        function displaySummaryStats() {
            const stats = matchingResults.stats;
            const results = matchingResults.results;

            const totalMatches = results.reduce((sum, r) => sum + r.matches.length, 0);
            const autoSelected = results.reduce((sum, r) => sum + (r.auto_selected ? r.auto_selected.length : 0), 0);
            const objectivesWithMatches = results.filter(r => r.matches.length > 0).length;

            document.getElementById('summaryStats').innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.total_objectives}</div>
                    <div class="stat-label">Learning Objectives</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalMatches}</div>
                    <div class="stat-label">Total Matches Found</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${objectivesWithMatches}</div>
                    <div class="stat-label">Objectives with Matches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${autoSelected}</div>
                    <div class="stat-label">Auto-Selected</div>
                </div>
            `;
        }

        function displayMatchCards() {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = '';

            matchingResults.results.forEach((result, resultIndex) => {
                const matchCard = document.createElement('div');
                matchCard.className = 'match-card';
                matchCard.innerHTML = `
                    <div class="match-header">
                        <div class="lo-text">${result.learning_objective}</div>
                    </div>
                    <div class="match-candidates" id="candidates-${resultIndex}"></div>
                `;

                const candidatesContainer = matchCard.querySelector(`#candidates-${resultIndex}`);

                if (result.matches.length === 0) {
                    candidatesContainer.innerHTML = '<div class="file-info">‚ùå No matches found for this objective</div>';
                } else {
                    result.matches.forEach((match, matchIndex) => {
                        const candidateCard = createCandidateCard(match, resultIndex, matchIndex, result.learning_objective);
                        candidatesContainer.appendChild(candidateCard);
                    });
                }

                container.appendChild(matchCard);
            });
        }

        function createCandidateCard(match, resultIndex, matchIndex, lo) {
            const card = document.createElement('div');
            card.className = 'candidate-card';
            card.dataset.resultIndex = resultIndex;
            card.dataset.matchIndex = matchIndex;
            card.dataset.noteId = match.note_id;
            card.dataset.lo = lo;

            card.innerHTML = `
                <div class="candidate-header">
                    <div style="flex: 1;">
                        <div class="score-container">
                            <div class="score-item">Combined: ${Math.round(match.combined_score * 100)}%</div>
                            <div class="score-item">Fuzzy: ${Math.round(match.fuzzy_score * 100)}%</div>
                            ${match.embedding_score > 0 ? `<div class="score-item">AI: ${Math.round(match.embedding_score * 100)}%</div>` : ''}
                        </div>
                    </div>
                    <input type="checkbox" style="transform: scale(1.3);" onchange="toggleCardSelection(this)">
                </div>
                <div class="card-preview">
                    <div style="font-size: 0.9rem; color: #666; margin-bottom: 8px;">
                        <strong>Model:</strong> ${match.model_name} |
                        <strong>Note ID:</strong> ${match.note_id}
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>Preview:</strong> ${match.preview_text}
                    </div>
                    ${match.tags && match.tags.length > 0 ? `
                        <div style="font-size: 0.85rem; color: #666;">
                            <strong>Tags:</strong> ${match.tags.join(', ')}
                        </div>
                    ` : ''}
                </div>
            `;

            card.addEventListener('click', function(e) {
                if (e.target.type !== 'checkbox') {
                    const checkbox = card.querySelector('input[type="checkbox"]');
                    checkbox.checked = !checkbox.checked;
                    toggleCardSelection(checkbox);
                }
            });

            return card;
        }

        // ==================== SELECTION MANAGEMENT ====================
        function toggleCardSelection(checkbox) {
            const card = checkbox.closest('.candidate-card');
            const noteId = parseInt(card.dataset.noteId);
            const lo = card.dataset.lo;

            if (checkbox.checked) {
                card.classList.add('selected');

                // Add to selected matches if not already present
                if (!selectedMatches.some(m => m.note_id === noteId && m.learning_objective === lo)) {
                    const resultIndex = parseInt(card.dataset.resultIndex);
                    const matchIndex = parseInt(card.dataset.matchIndex);
                    const match = matchingResults.results[resultIndex].matches[matchIndex];

                    selectedMatches.push({
                        learning_objective: lo,
                        note_id: noteId,
                        ...match
                    });
                }
            } else {
                card.classList.remove('selected');

                // Remove from selected matches
                selectedMatches = selectedMatches.filter(m =>
                    !(m.note_id === noteId && m.learning_objective === lo)
                );
            }

            updateSelectionUI();
        }

        function updateSelectionUI() {
            // Update checkboxes to match selectedMatches
            document.querySelectorAll('.candidate-card').forEach(card => {
                const noteId = parseInt(card.dataset.noteId);
                const lo = card.dataset.lo;
                const checkbox = card.querySelector('input[type="checkbox"]');
                const isSelected = selectedMatches.some(m =>
                    m.note_id === noteId && m.learning_objective === lo
                );

                checkbox.checked = isSelected;
                card.classList.toggle('selected', isSelected);
            });
        }

        function selectAll() {
            selectedMatches = [];

            matchingResults.results.forEach(result => {
                if (result.matches && result.matches.length > 0) {
                    // Select top match for each objective
                    const topMatch = result.matches[0];
                    selectedMatches.push({
                        learning_objective: result.learning_objective,
                        note_id: topMatch.note_id,
                        ...topMatch
                    });
                }
            });

            updateSelectionUI();
        }

        function clearSelections() {
            selectedMatches = [];
            updateSelectionUI();
        }

        // ==================== APPLY CHANGES ====================
        async function applyChanges() {
            if (selectedMatches.length === 0) {
                alert('Please select at least one card to apply changes.');
                return;
            }

            const dryRun = document.getElementById('dryRun').checked;
            const targetDeck = document.getElementById('targetDeck').value.trim();
            const customTag = document.getElementById('customTag').value.trim();

            const confirmMsg = dryRun
                ? `Preview: This would modify ${selectedMatches.length} cards. Continue?`
                : `This will modify ${selectedMatches.length} cards in your Anki collection. Continue?`;

            if (!confirm(confirmMsg)) return;

            const applyBtn = document.getElementById('applyBtn');
            const originalText = applyBtn.textContent;
            applyBtn.disabled = true;
            applyBtn.textContent = 'üîÑ Applying changes...';

            try {
                const response = await fetch(`${API_BASE}/apply-changes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selected_matches: selectedMatches,
                        target_deck: targetDeck,
                        custom_tag: customTag || null,
                        dry_run: dryRun
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    alert(data.message);
                    if (!dryRun) {
                        // Optionally refresh or update UI to show changes applied
                    }
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert(`Failed to apply changes: ${error.message}`);
            } finally {
                applyBtn.disabled = false;
                applyBtn.textContent = originalText;
            }
        }

        // ==================== EXPORT RESULTS ====================
        async function exportResults() {
            if (!matchingResults) {
                alert('No results to export.');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/export-results`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        results: matchingResults.results,
                        selected_matches: selectedMatches
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // Create and trigger download
                    const exportData = {
                        results: matchingResults.results,
                        selected_matches: selectedMatches,
                        config: matchingResults.config,
                        timestamp: new Date().toISOString()
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                        type: 'application/json'
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `decksurfer_results_${new Date().toISOString().slice(0,10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);

                    alert(`Results exported! (${data.rows} rows)`);
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                alert(`Export failed: ${error.message}`);
            }
        }

        // Monitor text input for manual objectives
        document.getElementById('manualObjectives').addEventListener('input', updateExtractButton);
    </script>
</body>